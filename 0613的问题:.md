### 0613的问题:

#### 懒加载是通过在get方法中添加if判断实现的，如果为空就创建，不为空直接返回。

* 变量的初始化是可以写在**viewDidLoad**里
  * 放到viewDidLoad里增加阅读难度，代码不简洁
  * 可能会有不用的属性，但是放到viewDidLoad里会创建（实际项目中一般不会，创建的属性都是有用的）

~~~objective-c
- (NSArray *)deals{
    if (!_deals) {
        _deals = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"tgs.plist" ofType:nil]];
    }
    NSMutableArray *tempArray = [NSMutableArray array];
    for (NSDictionary *dict in _deals) {
        DealModel *model = [DealModel dealWithDict:dict];
        [tempArray addObject:model];
    }
    _deals = tempArray;
    return _deals;
}
~~~

### 修改之后

~~~objective-c
- (NSMutableArray *)deals{
    if (!_deals) {
        _deals = [NSMutableArray array];
        NSArray *tempArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"tgs.plist" ofType:nil]];
        for (NSDictionary *dict in tempArray) {
            DealModel *model = [DealModel dealWithDict:dict];
            [_deals addObject:model];
        }
    }
    return _deals;
}
~~~

### 0614问题

#### 纯代码方式封装控件

- 1.在initWithFrame:方法中添加子控件（此方法中不能设置frame，进行初始化的操作）
- 2.在layoutSubviews方法中设置子控件的frame
- 3.重写模型的set方法

### 0615问题

- 对于tableView插入单行数据时，建议使用insertRowsAtIndexPaths:withRowAnimation方法，因为它有reloadData的功能，且性能更高，只刷新当前行，同时也有删除一行数据的动画效果方法：deleteRowsAtIndexPath:withRowAnimation。reloadData刷新行时是刷新所有行

- 从数组里取出对象不能用.语法，因为从数组中取出的对象是id类型的。

- tableview选中之后可以使用deselectRowIndexPath:方法可以取消选中状态

- 不能一边遍历一边删除数据

- 苹果系统自带的批量操作

  ```objective-c
  self.tableView.allowsMultipleSelectionDuringEditing = YES;
  ```

### 0621问题

* 一般情况下，类似`AFNetworking`的第三方库导入时使用<>,自己自定义的类用“”导入，系统的类也可以使用“”导入。

- 返回cell的估计高度，此方法调用后返回cell高度的方法会在返回cell的方法之后调用

```objective-c
- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 150;
}
```

* 不用MVC坏处：

  ~~~objective-c
  1.扩展性低，如添加一个状态的标志，需要修改很多代码
  2.字典的键值对字符串容易写错
  3.字典的值为空值容易导致崩溃，模型的话最多是UI上不显示的问题
  4.可维护性不高，如果后台字段改变，需要修改n多地方，mvc可能就只需修改转模型时一次就行
  ~~~

* 图片拉伸方式

  * 1.最早的拉伸方式,只拉伸1*1px的距离，现在已经过期

  ~~~objective-c
  image = [image stretchableImageWithLeftCapWith:topCapHeight:];
  right = width - left - 1;
  bottom = height - top - 1;
  ~~~

  * 2.

  ~~~objective-c
  UIImage *image = [UIImage imageWithNamed:@"ad"];
  image = [image resizeableImageWithCapInsets:UIEdgeInsetMake(10,10,10,10)]; //表示上下左右分别保护10px的距离
  ~~~

  *  3.不用代码方式，直接在storyboard中拉伸
  *  在storyboard中选中图片库中的图片，然后在右侧属性栏中选择下面“Slicing”中可以选择“水平、垂直”方向进行拉伸，且已经计算完毕拉伸位置和模式！！
     *   ![QQ20170621-0](images/QQ20170621-0.png)

### 0625问题

* KVC/KVO

  * KVC: Key Value Coding, 常见作用：给模型属性赋值
  * KVO: Key Value Observing, 常用作用：监听模型属性值的改变

* KVO用法：

  ~~~objective-c
  1.添加要监听的属性
    [self.p1 addObserver:self forKeyPath:@"name" options: NSKeyValueObservingOptionOld context:nil];
  2.监听属性发生改变时都会调用下面方法，是继承自NSObject的方法，所有对象都能监听
  #pragma mark - KVO监听方法
  /**
   * 当监听到object的keyPath属性发生了改变
   */
  - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
  {
      NSLog(@"监听到%@对象的%@属性发生了改变， %@", object, keyPath, change);
  }
  ~~~

* 代理和通知

  - 代理设计模式的作用:
    - 1.A对象监听B对象的一些行为，A成为B的代理
    - 2.B对象想告诉A对象一些事情，A成为B的代理
  - 代理设计模式的总结：
    - 如果你想监听别人的一些行为，那么你就要成为别人的代理
    - 如果你想告诉别人一些事情，那么就让别人成为你的代理
  - 代理设计模式的开发步骤
    - 1.拟一份协议（协议名字的格式：控件名 + Delegate），在协议里面声明一些代理方法（一般代理方法都是@optional）
    - 2.声明一个代理属性：@property (nonatomic, weak) id<代理协议> delegate;
    - 3.在内部发生某些行为时，调用代理对应的代理方法，通知代理内部发生什么事
    - 4.设置代理：xxx.delegate = yyy;
    - 5.yyy对象遵守协议，实现代理方法

  ~~~objective-c
  注意：代理调用方法时，成为代理的对象不一定实现代理方法，所以一定要判断是否有这个代理方法
    // 告诉代理
      if ([self.delegate  respondsToSelector:@selector(loadMoreFooterDidClickLoadMoreButton:)]) {
          [self.delegate loadMoreFooterDidClickLoadMoreButton:self];
      }
  ~~~

  ​

* 代理属性必须用weak，原因如下：![QQ20170625-0](images/QQ20170625-0.png)

* static的作用：

  - 修饰局部变量
    - 让局部变量只初始化一次
    - 局部变量在程序中只有一份内存
    - 并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）
  - 修饰全局变量
    - 全局变量的作用域仅限于当前文件

## 实现拷贝的方法

- copy
  - 只会产生不可变的副本对象（比如NSString）
- mutableCopy
  - 只会产生可变的副本对象（比如NSMutableString）
- ![QQ20170626-0](images/QQ20170626-0.png)

### 0626问题

- 问2-3年iOS开发经验的三个主要方面：
  - 事件处理：响应者链条
  - Runtime
  - RunLoop
- 主线程的主要作用：
  - 显示/刷新UI界面
  - 处理UI事件（比如点击事件、滚动事件、拖拽事件）
- 多线程常用的使用方案
- 一：GCD
  - 1.旨在替代NSThread等线程技术


- 2.充分利用设备的多核
  - 3.C语言编写，自动管理线程生命周期，经常使用
- 二：NSOperation：
  - 1.基于GCD（底层是GCD）
  - 2.比GCD多了一些更简单实用的功能
  - 3.使用更加面向对象
  - 4.OC语言编写，自动管理线程生命周期，经常使用   

### 0628问题：单粒模式

#### 延迟执行的3中方式

- ​

```objective-c
[self performSelector:@selector(run) withObject:nil afterDelay:2.0];
```

- ​

```objective-c
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@"run-----");
        });
```

- ​

```objective-c
[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:NO];
```

#### GCD的常见函数

- 屏障：在此之前的函数先执行，在此之后的函数后执行，异步也是一样

```objective-c
dispatch_barrier_async
```

- ​

```objective-c
static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSLog(@"------run");
    });
```

#### 单粒模式

* 调用alloc方法实际上底层是调用allWithZone方法

* 单粒模式的2中实现方式

  * 方式1：GCD方式

  ~~~objective-c
  // .h文件  (name)参数化，前面加##
  #define XMGSingletonH(name) + (instancetype)shared##name;

  // .m文件 1.宏定义：\表示换行，宏可以找到\下面的一行
  //2.alloc方法和copy方法实际上是调用的allocWithZone和copyWithZone方法，为了防止用户调用copy方法创建出第二份内存，实现了copyWithZone方法更严谨
  //3.static 是为了防止外界通过extern修改_instance的值添加的，也是为了安全
  #define XMGSingletonM(name) \
  static id _instance; \
   \
  + (instancetype)allocWithZone:(struct _NSZone *)zone \
  { \
      static dispatch_once_t onceToken; \
      dispatch_once(&onceToken, ^{ \
          _instance = [super allocWithZone:zone]; \
      }); \
      return _instance; \
  } \
   \
  + (instancetype)shared##name \
  { \
      static dispatch_once_t onceToken; \
      dispatch_once(&onceToken, ^{ \
          _instance = [[self alloc] init]; \
      }); \
      return _instance; \
  } \
   \
  - (id)copyWithZone:(NSZone *)zone \
  { \
      return _instance; \
  }
  ~~~

  * 方式2：加锁方式实现单粒：当多个线程同时创建对象时，添加锁可以防止多个线程同时创建对象

  ~~~objective-c
  static id _instance;

  + (instancetype)allocWithZone:(struct _NSZone *)zone
  {
      @synchronized(self) {//加锁的位置，在判断条件外
          if (_instance == nil) {
              _instance = [super allocWithZone:zone];
          }
      }
      return _instance;
  }

  + (instancetype)sharedInstance
  {
      @synchronized(self) {
          if (_instance == nil) {
              _instance = [[self alloc] init];
          }
      }
      return _instance;
  }

  - (id)copyWithZone:(NSZone *)zone
  {
      return _instance;
  }

  ~~~

  ​

### 0629问题:NSOperation

* NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类

* 使用NSOperation子类的方式有3种
  * NSInvocationOperation： 用的少，
    * 默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。
    * 只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作
  * NSBlockOperation
  * 自定义子类继承NSOperation，实现内部相应的方法(main方法)

* 添加操作到NSOperationQueue中

  ~~~objective-cb
  - (void)addOperation:(NSOperation *)op;
  - (void)addOperationWithBlock:(void (^)(void))block;
  ~~~

  ​

#### GCD的队列类型

- 并发队列
  - 自己创建的
  - 全局
- 串行队列
  - 主队列
  - 自己创建的

#### NSOperationQueue的队列类型

- 主队列
  - [NSOperationQueue mainQueue]
  - 凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行

- 非主队列（其他队列）
  - [[NSOperationQueue alloc] init]

  - 同时包含了：串行、并发功能：根据最大并发数的值确定是串行或者并发，最大并发数为1时，表示串行。-1表示线程数不受限制

    * 最大并发数的相关方法

      ~~~objective-c

      -(NSInteger)maxConcurrentOperationCount;

      -(void)setMaxConcurrentOperationCount:(NSInteger)cnt;
      ~~~

  - 添加到这种队列中的任务（NSOperation），就会自动放到子线程中执行

- 取消队列的所有操作

  ~~~objective-c
  -(void)cancelAllOperations;
  ~~~

  提示：也可以调用`NSOperation`的`-(void)cancel`方法取消单个操作

- 暂停和恢复队列

  ~~~objective-c
  - (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列
  - (BOOL)isSuspended;
  ~~~

- `NSOperation`之间可以设置依赖来保证执行顺序

  * 比如一定要让操作A执行完后，才能执行操作B，可以这么写

    ~~~objective-c
    [operationB addDependency:operationA]; // 操作B依赖于操作A
    ~~~

- 可以在不同queue的NSOperation之间创建依赖关系

  `注意：不能相互依赖;比如A依赖B，B依赖A`

- 可以监听一个操作的执行完毕

        ​~~~objective-c
    -(void(^)(void))completionBlock;
    -(void)setCompletionBlock:(void(^)(void))block;
        ​~~~

#### 自定义NSOperation的步骤很简单

* 重写`-(void)main`方法，在里面实现想执行的任务
  * 重写`-(void)main`方法的注意点
    * 自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）
    * 经常通过`-(BOOL)isCancelled`方法检测操作是否被取消，对取消做出响应


### RunLoop:底层是个do...while（）“死循环”

#### 基本作用

* 保持程序的持续运行
* 处理App中的各种事件（比如触摸事件、定时器事件、Selector事件）
* 节省CPU资源，提高程序性能：该做事时做事，该休息时休息
* ………….

#### RunLoop对象

* iOS中有2套API来访问和使用RunLoop
  * Foundation
    * NSRunLoop
  * Core Foundation
    * Core Foundation
* NSRunLoop和CFRunLoopRef都代表着RunLoop对象
* NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）
* CFRunLoopRef是开源的

#### RunLoop与线程

* 每条线程都有唯一的一个与之对应的RunLoop对象
* 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建
* RunLoop在第一次获取时创建，在线程结束时销毁

#### 获得RunLoop对象

* Foundation

~~~objective-c
[NSRunLoop currentRunLoop];// 获得当前线程的RunLoop对象

[NSRunLoop mainRunLoop];// 获得主线程的RunLoop对象
~~~

* Core Foundation

~~~objective-c
CFRunLoopGetCurrent();// 获得当前线程的RunLoop对象

CFRunLoopGetMain();// 获得主线程的RunLoop对象
~~~

#### RunLoop相关类

* Core Foundation中关于RunLoop的5个类
  * CFRunLoopRef
  * CFRunLoopModeRef
  * CFRunLoopSourceRef
  * CFRunLoopTimerRef
  * CFRunLoopObserverRef
* ![runloop1](/Users/senyint/Documents/note/images/runloop1.png)

#### CFRunLoopModeRef

* CFRunLoopModeRef代表RunLoop的运行模式
* 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer
* 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode
* 如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入
* 这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响
* 系统默认注册了5个Mode:
  * `kCFRunLoopDefaultMode`：App的默认Mode，通常主线程是在这个Mode下运行
  * `UITrackingRunLoopMode`：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode 影响
  * UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用
  * GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到
  * `kCFRunLoopCommonModes`: 这是一个占位用的Mode，不是一种真正的Mode

#### CFRunLoopSourceRef

* CFRunLoopSourceRef是事件源（输入源）
* 以前的分法
  * Port-BasedSources
  * Custom InputSources
  * Cocoa PerformSelector Sources
* 现在的分法
  * Source0：非基于Port的
  * Source1：基于Port的

#### CFRunLoopTimerRef

* CFRunLoopTimerRef是基于时间的触发器
* 基本上说的就是NSTimer

#### CFRunLoopObserverRef

* CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变
* 可以监听的时间点有以下几个
  * ![runloop2](images/runloop2.png)

#### RunLoop处理逻辑-官方版

* ![runloop3](images/runloop3.png)
* ![runloop4](images/runloop4.png)

#### RunLoop处理逻辑-网友整理版

* ![runloop5](images/runloop5.png)

#### RunLoop应用

* NSTimer
* ImageView显示：滑动scrollView时不显示图片，滑动结束显示图片
* PerformSelector
* 常驻线程:
  * 1.每次runloop运行之前会先判断mode是不是为空，如果为空，直接一开起就结束了
* 自动释放池：在RunLoop睡眠之前会释放（kCFRunLoopBeforeWaiting）


#### RunLoop面试题

* 什么是RunLoop
  * 1.从字面意思看，是运行循环、跑圈
  * 2.其实底层是do-while循环，在这个循环内部不断的处理各种任务（比如Source、Timer、Observer）
  * 一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop得手动启动（调用run方法）
  * RunLoop默认只能选择一个Mode启动，如果当前Mode中没有任何Source、Timer、Observer，那么就直接退出RunLoop
* 在开发中如何使用RunLoop？什么应用场景？
  * 开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来消息，处理其他事件）
    * 在子线程中开启一个定时器
    * 在子线程中进行一些长期监控
  * 可以控制定时器在特定模式下执行
  * 可以让某些事件（行为、任务）在特定模式下执行
  * 可以添加Observer监听RunLoop状态，比如监听点击事件的处理（在所有点击事件之前做一些事情）


#### GCD定时器

* `dispatch_source_t`是一个类(OC对象)，声明变量时，不带*，因为内部已经包含了*

~~~objective-c
int count = 0;
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 获得队列
//    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    // 创建一个定时器(dispatch_source_t本质还是个OC对象)
    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    
    // 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）
    // GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）
    // 何时开始执行第一个任务
    // dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒
    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));
    uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);
    dispatch_source_set_timer(self.timer, start, interval, 0);
    
    // 设置回调
    dispatch_source_set_event_handler(self.timer, ^{
        NSLog(@"------------%@", [NSThread currentThread]);
        count++;
        if (count == 4) {
            // 取消定时器
            dispatch_cancel(self.timer);
            self.timer = nil;
        }
    });
    
    // 启动定时器
    dispatch_resume(self.timer);
  
  //dispatch_source_create   虽然是creat，但是不用手动release。但是CF函数的还是需要手动release
}

~~~

# 3.多用字面量语法，少用与之等价的方法

~~~objective-c
NSString、NSNumber、NSArray、NSDictionary都属于Foundation框架
  
建议使用：
  NSStirng *str1 = @"hello";
  NSNumber *someNum = @2;
  NSNumber *someNum = @2.3f;
  NSNumber *someNum = @YES;
  NSArray *animals = @[obj1,obj2,obj3];
  dog = animals[2];
  NSDictionary *dict = @{
                           @"name":@"zxl",
                           @"sex":@"f",
                           @"age":@22
                           };
NSString *name = @[@"name"];
不建议使用：
  NSNumber *someNum = [NSNumber numberWithInt:1];
  NSArray *array = [NSArray arrayWithObjects:obj1,obj2,obj3];
  sd = [animal objectAtIndex:2];
  NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@"name",@"zxl",@"age",@22, nil];
  NSString *sd = [dict objectForKey:@"name"];
~~~

* 使用字面量语法（语法糖：计算机语言中与另外一套语法等效但是开发者用起来更加方便的语法。可令程序更易读，减少代码出错几率）可以缩减源代码长度，使其更为易读。字面量语法更精简
* 字面量语法对于数组来说，更容易操作数组。使用字面量语法创建数组时需注意，若数组元素对象中有nil则会抛出异常。对于上述例子中两种创建数组的方式，若obj1、obj3是有效对象，obj2是nil。若是按照字面量语法创建，则会抛出异常，若是按照不建议使用的方式创建则array中只有obj1这一个对象。
  * 原因在于：`arrayWithObjects：`这个方法会依次处理各个参数，直到发现nil为止，因为obj2是nil，所以该方法会提前结束
  * 这表明：字面量语法更安全。抛出异常令app终止执行，这比创建好数组之后才发现元素个数少了要好。向数组中插入nil通常说明程序有错，而通过异常可以更快的发现这个错误
* 字面量语法局限性